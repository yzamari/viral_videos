#!/usr/bin/env python3
"""
Demo: Refactored Video Generation System
Demonstrates the new audio-first, duration-controlled approach
"""

import os
import sys
import asyncio
import logging
from pathlib import Path

# Add src to path
sys.path.append(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'src'))

from src.core.duration_authority import DurationAuthority, ComponentType
from src.utils.audio_first_subtitle_generator import AudioFirstSubtitleGenerator
from src.utils.simplified_audio_processor import SimplifiedAudioProcessor
from src.generators.refactored_video_generator import RefactoredVideoGenerator, RefactoredVideoResult
from src.models.video_models import GeneratedVideoConfig, Platform, Language
from src.utils.session_context import create_session_context

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


async def demo_duration_authority():
    """Demonstrate Duration Authority functionality"""
    print("\n" + "="*60)
    print("üéØ DEMO: Duration Authority")
    print("="*60)
    
    # Create Duration Authority for 30-second video
    authority = DurationAuthority(target_duration=30.0, tolerance_percent=0.05)
    
    print(f"Target duration: {authority.get_target_duration()}s")
    print(f"Allowed range: {authority.get_min_allowed_duration():.1f}s - {authority.get_max_allowed_duration():.1f}s")
    
    # Get generation constraints
    constraints = authority.get_generation_constraints()
    print(f"Max words: {constraints['max_words']}")
    print(f"Max segments: {constraints['max_segments']}")
    print(f"Max clips: {constraints['max_clips']}")
    
    # Simulate component duration registration
    print("\nRegistering component durations:")
    
    # Script duration (estimated)
    script_valid = authority.register_component_duration(
        ComponentType.SCRIPT, 29.2, confidence=0.7
    )
    print(f"Script: 29.2s - {'‚úÖ Valid' if script_valid else '‚ùå Invalid'}")
    
    # Audio duration (measured)
    audio_valid = authority.register_component_duration(
        ComponentType.AUDIO, 30.1, confidence=1.0
    )
    print(f"Audio: 30.1s - {'‚úÖ Valid' if audio_valid else '‚ùå Invalid'}")
    
    # Subtitle duration (synced to audio)
    subtitle_valid = authority.register_component_duration(
        ComponentType.SUBTITLES, 30.1, confidence=1.0
    )
    print(f"Subtitles: 30.1s - {'‚úÖ Valid' if subtitle_valid else '‚ùå Invalid'}")
    
    # Get final recommendation
    final_duration = authority.get_final_duration_recommendation()
    print(f"\nRecommended final duration: {final_duration}s")
    
    # Validate final result
    is_valid, issues = authority.validate_final_result()
    print(f"Final validation: {'‚úÖ PASS' if is_valid else '‚ùå FAIL'}")
    if issues:
        for issue in issues:
            print(f"  - {issue}")


async def demo_audio_first_subtitles():
    """Demonstrate audio-first subtitle generation"""
    print("\n" + "="*60)
    print("üìù DEMO: Audio-First Subtitle Generation")
    print("="*60)
    
    # Create temporary directory for demo
    import tempfile
    with tempfile.TemporaryDirectory() as temp_dir:
        
        # Create mock audio files (in real usage these would be generated by TTS)
        audio_files = []
        script_segments = []
        
        for i in range(3):
            # Create mock audio file
            audio_file = os.path.join(temp_dir, f"segment_{i+1}.mp3")
            with open(audio_file, 'wb') as f:
                f.write(b"fake_audio_content" * 100)  # Some content for file size
            audio_files.append(audio_file)
            
            # Create corresponding script segment
            script_segments.append({
                'text': f"This is segment {i+1} of our demonstration video. "
                       f"The content explains how the new system works.",
                'duration': 3.5  # This estimate will be ignored
            })
        
        print(f"Created {len(audio_files)} mock audio files")
        print("Script segments with estimated durations (will be ignored):")
        for i, segment in enumerate(script_segments):
            print(f"  Segment {i+1}: {segment['duration']}s (estimated)")
        
        # Initialize subtitle generator
        generator = AudioFirstSubtitleGenerator(padding_between_segments=0.2)
        
        # Mock the audio duration method to return realistic values
        def mock_get_duration(audio_file):
            # Return different durations to show the system uses actual measurements
            durations = [2.8, 3.2, 2.1]  # Different from 3.5s estimates
            index = audio_files.index(audio_file)
            return durations[index]
        
        generator.get_audio_duration = mock_get_duration
        
        # Generate subtitles based on actual audio durations
        print("\nGenerating subtitles from ACTUAL audio durations:")
        srt_path, vtt_path, subtitle_segments = generator.generate_subtitles(
            audio_files=audio_files,
            script_segments=script_segments,
            output_dir=temp_dir,
            base_filename="demo_subtitles"
        )
        
        print(f"‚úÖ Created subtitle files:")
        print(f"  - SRT: {os.path.basename(srt_path)}")
        print(f"  - VTT: {os.path.basename(vtt_path)}")
        
        print("\nSubtitle timing (based on ACTUAL audio):")
        for segment in subtitle_segments:
            print(f"  {segment.start:.1f}s - {segment.end:.1f}s: {segment.text[:50]}...")
        
        # Show the content of SRT file
        print("\nSRT file content:")
        print("-" * 40)
        with open(srt_path, 'r', encoding='utf-8') as f:
            content = f.read()
            print(content[:300] + "..." if len(content) > 300 else content)


async def demo_simplified_audio_processing():
    """Demonstrate simplified audio processing"""
    print("\n" + "="*60) 
    print("üîß DEMO: Simplified Audio Processing")
    print("="*60)
    
    import tempfile
    
    with tempfile.TemporaryDirectory() as temp_dir:
        # Create mock audio files
        audio_files = []
        
        for i in range(3):
            audio_file = os.path.join(temp_dir, f"input_{i+1}.mp3")
            with open(audio_file, 'wb') as f:
                # Create files with different sizes to simulate different durations
                content_size = (i + 1) * 1000
                f.write(b"fake_audio_data" * content_size)
            audio_files.append(audio_file)
        
        print(f"Created {len(audio_files)} mock audio files")
        
        # Initialize simplified audio processor
        with SimplifiedAudioProcessor() as processor:
            
            # Mock the audio info method
            def mock_get_audio_info(audio_file):
                index = audio_files.index(audio_file)
                durations = [2.5, 3.1, 1.8]
                return {
                    'duration': durations[index],
                    'sample_rate': 44100,
                    'channels': 2,
                    'codec': 'mp3',
                    'bit_rate': 128000,
                    'file': audio_file
                }
            
            processor.get_audio_info = mock_get_audio_info
            
            # Validate audio files
            valid_files, invalid_files = processor.validate_audio_files(audio_files)
            print(f"Audio validation: {len(valid_files)} valid, {len(invalid_files)} invalid")
            
            # Show audio info
            print("\nAudio file information:")
            for audio_file in valid_files:
                info = processor.get_audio_info(audio_file)
                print(f"  {os.path.basename(audio_file)}: {info['duration']}s, "
                      f"{info['sample_rate']}Hz, {info['channels']}ch")
            
            print("\nSimplified concatenation approach:")
            print("‚úÖ No complex filter chains (eliminates stuttering)")
            print("‚úÖ Pre-normalize audio specs for consistency")
            print("‚úÖ Simple file-based concat (reliable)")
            print("‚úÖ No crossfade (major cause of artifacts)")


async def demo_complete_pipeline():
    """Demonstrate the complete refactored pipeline"""
    print("\n" + "="*60)
    print("üöÄ DEMO: Complete Refactored Pipeline")
    print("="*60)
    
    # This would be a complete demo using the RefactoredVideoGenerator
    # For now, show the conceptual flow
    
    print("NEW PIPELINE FLOW:")
    print("1. üéØ Duration Authority creates constraints")
    print("   - Target: 30s, Max words: 69, Max segments: 15")
    print()
    print("2. üìù Script generation with constraints")
    print("   - Generate script within word limit")
    print("   - Register estimated duration with authority")
    print()
    print("3. üéµ Audio generation (ACTUAL durations)")
    print("   - Generate TTS audio from script")
    print("   - Measure actual durations using FFprobe")
    print("   - Register measured durations with authority")
    print()
    print("4. üìù Subtitle generation from audio")
    print("   - Create subtitles using ACTUAL audio durations")
    print("   - Perfect sync guaranteed (no estimation)")
    print("   - Register subtitle durations with authority")
    print()
    print("5. üé¨ Video generation with constraints")
    print("   - Generate clips within duration limits")
    print("   - Use simplified audio processing")
    print("   - Register final video duration")
    print()
    print("6. ‚úÖ Final validation")
    print("   - All components within 5% tolerance")
    print("   - Audio-subtitle sync perfect")
    print("   - No stuttering or artifacts")
    
    print("\nBENEFITS OF NEW APPROACH:")
    print("‚úÖ Eliminates audio-subtitle sync issues")
    print("‚úÖ Prevents audio stuttering from complex filters")
    print("‚úÖ Ensures consistent duration management")
    print("‚úÖ Single source of truth for all duration decisions")
    print("‚úÖ Measurement-based instead of estimation-based")


async def main():
    """Run all demos"""
    print("üé¨ REFACTORED VIDEO GENERATION SYSTEM DEMO")
    print("Solving audio-subtitle sync, stuttering, and duration issues")
    
    await demo_duration_authority()
    await demo_audio_first_subtitles()
    await demo_simplified_audio_processing()
    await demo_complete_pipeline()
    
    print("\n" + "="*60)
    print("üéâ DEMO COMPLETE")
    print("="*60)
    print("To use the refactored system:")
    print("1. Run migration: python scripts/migrate_to_refactored_system.py")
    print("2. Run tests: python -m pytest tests/test_refactored_video_generation.py")
    print("3. Generate video: Use RefactoredVideoGenerator instead of old VideoGenerator")
    print()
    print("Expected improvements:")
    print("- Perfect audio-subtitle synchronization")
    print("- No audio stuttering or artifacts")
    print("- Consistent video durations within 5% tolerance")
    print("- Reliable, predictable video generation")


if __name__ == "__main__":
    asyncio.run(main())